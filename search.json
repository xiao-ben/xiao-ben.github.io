[{"title":"小程序无限路由方案（proxy 实现）","url":"%2F2019%2F05%2F05%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%A0%E9%99%90%E8%B7%AF%E7%94%B1%E6%96%B9%E6%A1%88%EF%BC%88proxy%20%E5%AE%9E%E7%8E%B0%EF%BC%89%2F","content":"\n### 背景\n\n- 小程序历史栈最多只支持10层\n- 当小程序业务比较复杂时，就很容易超过10层。\n- 当超过10层后，有的机型是点击无反应，有的机型会出现一些未知错误\n\n<!--more-->\n\n### 解决方法\n\n- 修改小程序默认导航行为，自行维护 `pages`\n- 页面层级小于等于10时，导航行为与原生导航行为一致，每次改动都记录到 `pages`\n- 请求打开第11层及以上时，实际层级每次都是直接将第10层替换为目标页面\n- 返回时，逻辑层级相应回退；若回退后逻辑层级大于等于10，则实际层级将第10层替换为目标页面，否则实际层级回退到相应页面\n\n\n举例\n```\n  逻辑层级 1 - 2 - ... - 8 - 9 - 10\n  实际层级 1 - 2 - ... - 8 - 9 - 10\n  \n  打开\n  \n  逻辑层级 1 - 2 - ... - 8 - 9 - 10 - 11\n  实际层级 1 - 2 - ... - 8 - 9 - 11\n  \n  打开，打开，打开\n  \n  逻辑层级 1 - 2 - ... - 8 - 9 - 10 - 11 - 12 - 13 - 14\n  实际层级 1 - 2 - ... - 8 - 9 - 14\n  \n  返回\n  \n  逻辑层级 1 - 2 - ... - 8 - 9 - 10 - 11 - 12 - 13\n  实际层级 1 - 2 - ... - 8 - 9 - 13\n  \n  返回，返回，返回\n  \n  逻辑层级 1 - 2 - ... - 8 - 9 - 10\n  实际层级 1 - 2 - ... - 8 - 9 - 10\n  \n  返回\n  \n  逻辑层级 1 - 2 - ... - 8 - 9\n  实际层级 1 - 2 - ... - 8 - 9\n```\n\n### 思路\n这里采用一种比较特殊的办法，可以不影响业务代码，不需要添加任何其他的代码\n\n我们通过 `proxy` 的方式，改变全局变量 `wx` ，将全部路由跳转的方式都进行代理，在这个过程里维护我们自己的 `pages` 即可。\n\n在 app.js 里 \n\n```jsx\nimport {router} from 'lib/router'\n// 修改路由跳转方式（打破小程序 10 层限制）\nwx = new Proxy(wx, router)\n```\n\n新建文件 `/lib/router.js`\n\n```jsx\nclass Router {\n  constructor() {\n    this.maxPagesCount = 10\n    this.pages = []\n  }\n\n  get(target, key, receiver) {\n    try {\n      switch (key) {\n        case 'navigateTo':\n        case 'redirectTo':\n        case 'switchTab':\n          return data => this.changeRouter(data, target, key, receiver)\n        case 'navigateBack':\n          return data => this.destroyPage(data, target, key, receiver)\n        case 'reLaunch':\n          this.pages = []\n          return Reflect.get(target, key, receiver)\n        default:\n          return Reflect.get(target, key, receiver)\n      }\n    } catch (e) {\n      // 错误时重启 app\n      return Reflect.get(target, 'reLaunch', receiver)\n    }\n  }\n\n  changeRouter(data, target, key, receiver) {\n    const {url} = data\n    if (this.pages.length < this.maxPagesCount - 1) {\n      try {\n        switch (key) {\n          case 'navigateTo':\n          case 'switchTab':\n            this.pushPage(url)\n            break\n          case 'redirectTo':\n            this.popPage()\n            this.pushPage(url)\n            break\n          default:\n            break\n        }\n        Reflect.get(target, key, receiver)(data)\n      } catch (e) {\n        Reflect.get(target, 'reLaunch', receiver)(data)\n      }\n    } else {\n      this.pushPage(url)\n      Reflect.get(target, 'redirectTo', receiver)(data)\n    }\n    console.log(this.pages, 'pages');\n  }\n\n  destroyPage(data, target, key, receiver) {\n    if (this.pages.length < this.maxPagesCount) {\n      this.popPage()\n      Reflect.get(target, key, receiver)(data)\n    } else {\n      this.popPage()\n      const url = this.pages.slice(-1)[0]\n      Reflect.get(target, 'redirectTo', receiver)({url})\n    }\n    console.log(this.pages, 'pages');\n  }\n\n  pushPage(url) {\n    this.pages.push(url)\n  }\n\n  popPage(e) {\n    return this.pages.pop()\n  }\n}\n\nexport const router = new Router()\n```\n","tags":["小程序"]}]